#########################################################################
#  Python helper code                                                   #
#########################################################################

global !p
import vim
import os.path
def get_module_namespace_and_basename():
	"""This function will try to guess the current class or define name you are
	trying to create. Note that for this to work you should be using the module
	structure as per the style guide. Examples inputs and it's output
	* /home/nikolavp/puppet/modules/collectd/manifests/init.pp -> collectd
	* /home/nikolavp/puppet/modules/collectd/manfistes/mysql.pp -> collectd::mysql
	"""
	first_time = True
	current_file_path_without_ext = vim.eval('expand("%:p:r")') or ""
	if not current_file_path_without_ext:
		return "name"
	parts = os.path.split(current_file_path_without_ext)
	namespace = ''
	while parts[0] and parts[0] != '/':
		if parts[1] == 'init' and first_time and not namespace:
			first_time = False
			parts = os.path.split(parts[0])
			continue
		if parts[1] == 'manifests':
			return os.path.split(parts[0])[1] + ('::' + namespace).rstrip(':')
		else:
			namespace = parts[1] + '::' + namespace
		parts = os.path.split(parts[0])
	# couldn't guess the namespace. The user is editing a raw file in no module like the site.pp file
	return "name"
endglobal

###############################################################################
#  Puppet Language Constructs                                                 #
#    See http://docs.puppetlabs.com/puppet/latest/reference/lang_summary.html #
###############################################################################
snippet file "File resource type" b
file { '${1:name}':
	ensure  => '${2:file}',
	owner   => '${3:root}',
	group   => '${4:root}',
	mode    => '${5:0644}',
	source  => 'puppet:///modules/${6:module}/${7:source}',
	content => template('${8:template}'),
	require => [ Package['${10:package}'], File['${11:file}'], ],
}
endsnippet

snippet pacakge "Package resource type" b
package { '${1:name}':
	ensure => '${2:installed}',
}
endsnippet

snippet service "Service resource type" b
service { '${1:name}':
	ensure    => '${2:running}',
	enable    => ${3:true},
	hasstatus => ${4:true},
}
endsnippet

snippet class
class { '${1}':
	${2}
}
endsnippet

snippet firewall
firewall { '050 Open port ${1}':
	dport  => $1,
	action => 'accept',
}
endsnippet

snippet =os "selector on OS" b
= $::operatingsystem ? {
	/(redhat|centos)/ => 'bin',
	/(ubuntu|debian)/ => 'bin',
	default           => undef,
}
endsnippet

snippet = "selector on OS family" b
= $::osfamily ? {
	'Debian' => 'bin',
	'RedHat' => 'bin',
	default  => undef,
}
endsnippet

# Header to match http://docs.puppetlabs.com/guides/style_guide.html#puppet-doc
snippet classheader "Class declaration" b
# == Class: ${1:`!p snip.rv = get_module_namespace_and_basename()`}
#
# ${2:Full description of class $1 here}
#
# === Parameters
#
# Document parameters here.
#
# [*parameter1*]
#   Explanation of what this parameter affects and what it defaults to.
#   e.g. "Specify one or more upstream ntp servers as an array."
#
# === Variables
#
# Here you should define a list of variables that this module would require.
#
# [*variable1*]
#   Explanation of how this variable affects the funtion of this class and
#   if it has a default. e.g. "The parameter enc_ntp_servers must be set by the
#   External Node Classifier as a comma separated list of hostnames."
#
# === Examples
#
#  class { '$1':
#    parameter1 => [ 'just', 'an', 'example', ]
#  }
#
# === Authors
#
# `!v g:snips_author` <`!v g:snips_author_email`>
#
# === Copyright
#
# Copyright `!v strftime("%Y")` `!v g:snips_author`
#
class $1 (${3}) {
	${4}
}
endsnippet

# vim:ft=snippets:
